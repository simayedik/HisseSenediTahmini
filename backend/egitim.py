# -*- coding: utf-8 -*-
"""yapayzekauygulamalari.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18nBG0CCweSkE-51M28J7FNB7dsyHsr-U
"""

import yfinance as yf
import pandas as pd

tickers = [
    "SISE.IS", "GARAN.IS", "ASELS.IS", "THYAO.IS",
    "TTRAK.IS", "YKBNK.IS", "AYDEM.IS", "ISDMR.IS", "TSKB.IS"
]

data = yf.download(tickers, start="2018-01-01", end="2024-12-31")
close_prices = data["Close"].dropna()
close_prices.head()

# ------------------ Teknik Gösterge Hesaplama Fonksiyonları ------------------

def compute_rsi(data, window=14):
    delta = data.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

def compute_macd(data, slow=26, fast=12, signal=9):
    exp1 = data.ewm(span=fast, adjust=False).mean()
    exp2 = data.ewm(span=slow, adjust=False).mean()
    macd = exp1 - exp2
    signal_line = macd.ewm(span=signal, adjust=False).mean()
    return macd, signal_line

def compute_bollinger_bands(data, window=20):
    sma = data.rolling(window=window).mean()
    std = data.rolling(window=window).std()
    upper_band = sma + (std * 2)
    lower_band = sma - (std * 2)
    return upper_band, lower_band

def compute_momentum(data, window=10):
    return data - data.shift(window)

def compute_volatility(data, window=20):
    return data.rolling(window=window).std()

# ------------------ Örnek kullanım ------------------
# garan = prepare_features(close_prices, "GARAN.IS")
# sise = prepare_features(close_prices, "SISE.IS")

def prepare_features(df, ticker):
    df = df[[ticker]].copy()  # Sadece seçilen hisse
    df["target"] = df[ticker].shift(-1)  # Yarınki fiyat hedefi

    # Lag özellikleri (önceki 5 gün)
    for i in range(1, 6):
        df[f"lag_{i}"] = df[ticker].shift(i)

    # Hareketli ortalamalar
    df["ma_3"] = df[ticker].rolling(window=3).mean()
    df["ma_7"] = df[ticker].rolling(window=7).mean()

    # Yüzdelik değişim
    df["pct_change"] = df[ticker].pct_change()

    # Momentum
    df["momentum_3"] = df[ticker] - df[ticker].shift(3)
    df["momentum_7"] = df[ticker] - df[ticker].shift(7)

    # Volatilite (standart sapma)
    df["volatility_3"] = df[ticker].rolling(window=3).std()
    df["volatility_7"] = df[ticker].rolling(window=7).std()

    # --- Teknik Göstergeler ---
    df["RSI_14"] = compute_rsi(df[ticker])
    df["MACD"], df["MACD_signal"] = compute_macd(df[ticker])
    df["BB_upper"], df["BB_lower"] = compute_bollinger_bands(df[ticker])
    df["Momentum_10"] = compute_momentum(df[ticker])
    df["Volatility_20"] = compute_volatility(df[ticker])

    # Eksik verileri temizle
    df = df.dropna().reset_index(drop=True)
    return df

from sklearn.linear_model import Ridge, Lasso, ElasticNet
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import train_test_split
import numpy as np


def train_ridge_model(df, ticker):
    print(f"\n--- {ticker} için model eğitimi başlatılıyor ---")
    df_prepared = prepare_features(df, ticker)

    # Giriş ve hedef değişkenler
    feature_cols = [f"lag_{i}" for i in range(1, 6)] + [
        "ma_3", "ma_7", "pct_change",
        "momentum_3", "momentum_7",
        "volatility_3", "volatility_7",
        "RSI_14", "MACD", "MACD_signal",
        "BB_upper", "BB_lower",
        "Momentum_10", "Volatility_20"]

    X = df_prepared[feature_cols]
    y = df_prepared["target"]

    # Eğitim/Test veri bölme
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

    # Ridge Regression Modeli
    model = Ridge(alpha=0.0043)  # Daha önce optimizasyonla bulunmuş alpha
    model.fit(X_train, y_train)

    # Tahmin ve değerlendirme
    y_pred = model.predict(X_test)
    rmse = np.sqrt(mean_squared_error(y_test, y_pred))
    print(f"{ticker} RMSE: {rmse:.4f}")
    return model, rmse

model, hata = train_ridge_model(close_prices, "THYAO.IS")
model, hata = train_ridge_model(close_prices, "ISDMR.IS")

from sklearn.ensemble import RandomForestRegressor
def compare_models(df, ticker):
    print(f"\n--- {ticker} için modeller karşılaştırılıyor ---")
    df_prepared = prepare_features(df, ticker)

    feature_cols = [f"lag_{i}" for i in range(1, 6)] + [
        "ma_3", "ma_7", "pct_change",
        "momentum_3", "momentum_7",
        "volatility_3", "volatility_7",
        "RSI_14", "MACD", "MACD_signal",
        "BB_upper", "BB_lower",
        "Momentum_10", "Volatility_20"]

    X = df_prepared[feature_cols]
    y = df_prepared["target"]

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

    models = {
        "Ridge": Ridge(alpha=0.0043),
        "Lasso": Lasso(alpha=0.01, max_iter=10000),
        "ElasticNet": ElasticNet(alpha=0.01, l1_ratio=0.5, max_iter=10000),
        "RandomForest": RandomForestRegressor(n_estimators=100, random_state=42)
    }

    results = {}
    for name, model in models.items():
        model.fit(X_train, y_train)
        y_pred = model.predict(X_test)
        rmse = np.sqrt(mean_squared_error(y_test, y_pred))
        results[name] = rmse
        print(f"{name} RMSE: {rmse:.4f}")

    return results

# results = compare_models(close_prices, "THYAO.IS")
results = compare_models(close_prices, "SISE.IS")

from sklearn.model_selection import train_test_split, GridSearchCV, TimeSeriesSplit
def tune_and_compare_models(df, ticker):
    print(f"\n--- {ticker} için modeller optimize ediliyor ---")
    df_prepared = prepare_features(df, ticker)

    feature_cols = [f"lag_{i}" for i in range(1, 6)] + [
        "ma_3", "ma_7", "pct_change",
        "momentum_3", "momentum_7",
        "volatility_3", "volatility_7",
        "RSI_14", "MACD", "MACD_signal",
        "BB_upper", "BB_lower",
        "Momentum_10", "Volatility_20"]

    X = df_prepared[feature_cols]
    y = df_prepared["target"]

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

    tscv = TimeSeriesSplit(n_splits=5)

    models = {
        "Ridge": (Ridge(), {"alpha": np.logspace(-4, 2, 20)}),
        "Lasso": (Lasso(max_iter=10000), {"alpha": np.logspace(-4, 1, 20)}),
        "ElasticNet": (ElasticNet(max_iter=10000), {
            "alpha": np.logspace(-4, 1, 10),
            "l1_ratio": np.linspace(0, 1, 5)
        }),
        "RandomForest": (RandomForestRegressor(random_state=42), {
            "n_estimators": [100, 200],
            "max_depth": [None, 5, 10],
            "min_samples_split": [2, 5]
        })
    }

    results = {}

    for name, (model, params) in models.items():
        grid = GridSearchCV(model, params, cv=tscv, scoring='neg_root_mean_squared_error', n_jobs=-1)
        grid.fit(X_train, y_train)
        best_model = grid.best_estimator_
        y_pred = best_model.predict(X_test)
        rmse = np.sqrt(mean_squared_error(y_test, y_pred))
        results[name] = rmse
        print(f"{name} (Best Params: {grid.best_params_}) => RMSE: {rmse:.4f}")


    return results

results = tune_and_compare_models(close_prices, "GARAN.IS")
results = tune_and_compare_models(close_prices, "SISE.IS")

from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
import numpy as np
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import train_test_split, GridSearchCV, TimeSeriesSplit
from sklearn.linear_model import Ridge, Lasso, ElasticNet
from xgboost import XGBRegressor
from sklearn.svm import SVR


def compute_nrmse(y_true, y_pred):
    return np.sqrt(mean_squared_error(y_true, y_pred)) / (y_true.max() - y_true.min())

def compute_mape(y_true, y_pred):
    return np.mean(np.abs((y_true - y_pred) / y_true)) * 100

def tune_and_compare_models_plot(df, ticker):
    print(f"\n--- {ticker} için modeller optimize ediliyor ---")
    df_prepared = prepare_features(df, ticker)

    feature_cols = [f"lag_{i}" for i in range(1, 6)] + [
        "ma_3", "ma_7", "pct_change",
        "momentum_3", "momentum_7",
        "volatility_3", "volatility_7",
        "RSI_14", "MACD", "MACD_signal",
        "BB_upper", "BB_lower",
        "Momentum_10", "Volatility_20"]

    X = df_prepared[feature_cols]
    y = df_prepared["target"]

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)
    tscv = TimeSeriesSplit(n_splits=5)

    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_test_scaled = scaler.transform(X_test)

    models = {
        "ElasticNet": (ElasticNet(max_iter=10000), {
            "alpha": np.logspace(-4, 1, 10),
            "l1_ratio": np.linspace(0, 1, 5)
        }),
         "XGBoost": (XGBRegressor(objective='reg:squarederror', random_state=42), {
               "n_estimators": [100, 200],
                "learning_rate": [0.01, 0.1],
                "max_depth": [3, 5],
                "subsample": [0.7, 1.0],
                "colsample_bytree": [0.7, 1.0]
          }),
       "SVR": (SVR(), {
         "kernel": ["linear", "rbf"],
         "C": [0.1, 1, 10],
       "epsilon": [0.01, 0.1]
        }),

    }

    results = {}


    for name, (model, params) in models.items():
        grid = GridSearchCV(model, params, cv=tscv, scoring='neg_root_mean_squared_error', n_jobs=-1)
        grid.fit(X_train_scaled, y_train)
        best_model = grid.best_estimator_
        y_pred = best_model.predict(X_test_scaled)
        rmse = np.sqrt(mean_squared_error(y_test, y_pred))
        r2 = r2_score(y_test, y_pred)
        nrmse = compute_nrmse(y_test, y_pred)
        mape = compute_mape(y_test, y_pred)

        results[name] = {
          "RMSE": rmse,
          "R²": r2,
          "NRMSE": nrmse,
          "MAPE": mape
      }

        print(f"{name} (Best Params: {grid.best_params_})")
        print(f"  RMSE: {rmse:.4f} | R²: {r2:.4f} | NRMSE: {nrmse:.4f} | MAPE: {mape:.2f}%")


        # Grafik
        plt.figure(figsize=(12, 5))
        plt.plot(y_test.values, label="Gerçek Fiyat", color='black')
        plt.plot(y_pred, label="Tahmin", color='blue', linestyle='dashed')
        plt.title(f"{ticker} – {name} Modeli: Gerçek vs Tahmin")
        plt.xlabel("Gün")
        plt.ylabel("Fiyat")
        plt.legend()
        plt.grid(True)
        plt.show()

    return results

# results = tune_and_compare_models_plot(close_prices, "GARAN.IS")
results = tune_and_compare_models_plot(close_prices, "SISE.IS")

import joblib
from sklearn.linear_model import ElasticNet
from sklearn.svm import SVR
from xgboost import XGBRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
import numpy as np

# Veriyi hazırla
df = prepare_features(close_prices, "SISE.IS")  # Örnek: Şişe Cam
feature_cols = [f"lag_{i}" for i in range(1, 6)] + [
    "ma_3", "ma_7", "pct_change", "momentum_3", "momentum_7",
    "volatility_3", "volatility_7", "RSI_14", "MACD", "MACD_signal",
    "BB_upper", "BB_lower", "Momentum_10", "Volatility_20"]

X = df[feature_cols]
y = df["target"]

X_train, X_test, y_train, y_test = train_test_split(X, y, shuffle=False, test_size=0.2)

# Ölçekleme
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)

# MODELLER
elastic = ElasticNet(alpha=0.0001, l1_ratio=1.0, max_iter=10000).fit(X_train_scaled, y_train)
svr = SVR(C=10, epsilon=0.01, kernel='linear').fit(X_train_scaled, y_train)
xgb = XGBRegressor(n_estimators=100, learning_rate=0.1, max_depth=3,
                   subsample=0.7, colsample_bytree=0.7).fit(X_train_scaled, y_train)

# MODELLERİ KAYDET (.pkl)
joblib.dump(elastic, "elastic_model.pkl")
joblib.dump(svr, "svr_model.pkl")
joblib.dump(xgb, "xgb_model.pkl")
joblib.dump(scaler, "scaler.pkl")

results = tune_and_compare_models_plot(close_prices, "GARAN.IS")
results = tune_and_compare_models_plot(close_prices, "SISE.IS")

import matplotlib.pyplot as plt
from sklearn.neural_network import MLPRegressor
from sklearn.svm import SVR
from xgboost import XGBRegressor
from sklearn.preprocessing import StandardScaler

def compute_nrmse(y_true, y_pred):
    return np.sqrt(mean_squared_error(y_true, y_pred)) / (y_true.max() - y_true.min())

def compute_mape(y_true, y_pred):
    return np.mean(np.abs((y_true - y_pred) / y_true)) * 100

def tune_and_compare_models_plot2(df, ticker):
    print(f"\n--- {ticker} için modeller optimize ediliyor ---")
    df_prepared = prepare_features(df, ticker)

    feature_cols = [f"lag_{i}" for i in range(1, 6)] + [
        "ma_3", "ma_7", "pct_change",
        "momentum_3", "momentum_7",
        "volatility_3", "volatility_7",
        "RSI_14", "MACD", "MACD_signal",
        "BB_upper", "BB_lower",
        "Momentum_10", "Volatility_20"]

    X = df_prepared[feature_cols]
    y = df_prepared["target"]

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)
    tscv = TimeSeriesSplit(n_splits=5)


    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_test_scaled = scaler.transform(X_test)

    models = {
       "XGBoost": (XGBRegressor(objective='reg:squarederror', random_state=42), {
               "n_estimators": [100, 200],
                "learning_rate": [0.01, 0.1],
                "max_depth": [3, 5],
                "subsample": [0.7, 1.0],
                "colsample_bytree": [0.7, 1.0]
          }),
       "SVR": (SVR(), {
         "kernel": ["linear", "rbf"],
         "C": [0.1, 1, 10],
       "epsilon": [0.01, 0.1]
        }),
        "MLP": (MLPRegressor(max_iter=1000, random_state=42), {
            "hidden_layer_sizes": [(50,), (100,), (50, 50)],
        "activation": ["relu", "tanh"],
         "alpha": [0.0001, 0.001]
})
    }

    results = {}

    for name, (model, params) in models.items():
        grid = GridSearchCV(model, params, cv=tscv, scoring='neg_root_mean_squared_error', n_jobs=-1)
        grid.fit(X_train_scaled, y_train)
        best_model = grid.best_estimator_
        y_pred = best_model.predict(X_test_scaled)
        rmse = np.sqrt(mean_squared_error(y_test, y_pred))
        r2 = r2_score(y_test, y_pred)
        nrmse = compute_nrmse(y_test, y_pred)
        mape = compute_mape(y_test, y_pred)

        results[name] = {
         "RMSE": rmse,
         "R²": r2,
        "NRMSE": nrmse,
        "MAPE": mape
        }

        results[name] = rmse

        print(f"{name} (Best Params: {grid.best_params_})")
        print(f"  RMSE: {rmse:.4f} | R²: {r2:.4f} | NRMSE: {nrmse:.4f} | MAPE: {mape:.2f}%")

        # Grafik
        plt.figure(figsize=(12, 5))
        plt.plot(y_test.values, label="Gerçek Fiyat", color='black')
        plt.plot(y_pred, label="Tahmin", color='blue', linestyle='dashed')
        plt.title(f"{ticker} – {name} Modeli: Gerçek vs Tahmin")
        plt.xlabel("Gün")
        plt.ylabel("Fiyat")
        plt.legend()
        plt.grid(True)
        plt.show()

    return results

# results = tune_and_compare_models_plot2(close_prices, "GARAN.IS")
results = tune_and_compare_models_plot2(close_prices, "SISE.IS")

results = tune_and_compare_models_plot2(close_prices, "SISE.IS")
# results = tune_and_compare_models_plot2(close_prices, "GARAN.IS")

results = tune_and_compare_models_plot2(close_prices, "GARAN.IS")